挑战3

计算器执行中包含下面的三个参数：

    -c 配置文件 配置文件，由于各地的社保比例稍有不同，我们为每个城市提供一个社保比例的配置文件
    -d 员工工资数据文件 指定员工工资数据文件，文件中包含两列内容，分别为员工工号和工资金额
    -o 员工工资单数据文件 输出内容，将员工缴纳的社保、税前、税后工资等详细信息输出到文件中

配置文件格式如下，具体数字每个城市稍有不同：

JiShuL = 2193.00
JiShuH = 16446.00
YangLao = 0.08
YiLiao = 0.02
ShiYe = 0.005
GongShang = 0
ShengYu = 0
GongJiJin = 0.06

JiShuL 为社保缴费基数的下限，即工资低于 JiShuL 的值的时候，需要按照该数字乘以缴费比例来缴纳社保，JiShuH 为社保缴费基数的上限，即工资高于 JiShuH 的值的时候，需要按照 JiShuH 乘以缴费比例缴纳社保。工资在 JiShuL 和 JiShuH之间时候，需要按照你实际的工资金额乘以缴费比例计算社保费用。

例如工资为20000，但社保基数为 2193 ～ 16446，所以应该缴纳的社保就是用社保基数上限 16446 去乘以社保的比例计算实际缴纳的社保数，而不是用 20000。

配置文件中其他项目为社保及公积金的缴费比例。

员工工资数据文件格式每行为 工号,税前工资，举例如下：

101,3500
203,5000
309,15000

输出的员工工资单数据文件中，每行格式为 工号,税前工资,社保金额,个税金额,税后工资如下：

101,3500,577.50,0.00,2922.50
203,5000,825.00,20.25,4154.75
309,15000,2475.00,1251.25,11273.75

注意，这只是测试用例的输出，测试时候用的数据文件可能有更多的行，输出的文件行数要与测试文件行数相同，但不需要保持相同的顺序。

程序的执行过程如下，注意配置文件 test.cfg 和输入的员工数据文件 user.csv 需要你自己创建并填入数据（可以参考上述的内容示例），并且文件可以放在任何位置，只要参数中指定文件的路径就可以了：

$ ./calculator.py -c /home/shiyanlou/test.cfg -d /home/shiyanlou/user.csv -o /tmp/gongzi.csv

执行成功不需要输出信息到屏幕，执行失败或有异常出现则将错误信息输出到屏幕。
目标

完成任务需要达成的目标：

    程序存放的位置 /home/shiyanlou/calculator.py
    程序必须对文件是否存在是否符合格式要求进行判断，如果有错误需要打印错误信息并退出
    程序返回的税后工资、个税及社保数字保留两位小数，如果是整数，仍然需要保留xxx.00 这种形式

提示语

下述实现方案仅供参考，会涉及到先前实验中学习到的知识点，如果自己对程序有足够的理解也可以不按照下述提示编写

    需要注意社保基数的处理，比如 20000 元工资高于社保基数的上限 JiShuH 的值，就应该用 JiShuH 这个值去乘以比例计算需要缴纳的社保金额
    可以实现一个配置类 Config，来获取并存储配置文件中的信息，Config 类 def __init__(self, configfile) 中定义一个字典 self._config = {} 来存储每个配置项和值，从文件中读取的时候需要注意使用 strip() 去掉空格，并可以使用字符串的 split('=') 将配置项和值切分开。从 Config 对象中获得配置信息的方法可以定义为 def get_config(self)，使用类似 config.get_config('JiShuH')
    可以实现一个员工数据类 UserData，来获取并存储员工数据，同样 def __init__(self, userdatafile) 中定义一个字典 self.userdata = {} 存储文件中读取的用户 ID及工资，并实现相应的金额计算的方法def calculator(self) 及输出到文件中的方法 def dumptofile(self, outputfile)。
    需要在上述类中实现文件读取和写入等操作，写入的格式需要保证符合上述描述内容
    处理命令行参数的方式：

    首先使用 args = sys.argv[1:] 获得所有的命令行参数列表，即包括 -c test.cfg -d user.csv -o gongzi.csv 这些内容
    使用 index = args.index('-c') 获得 -c 参数的索引，那么配置文件的路径就是 -c 后的参数即 configfile = args[index+1]，同样，其他的 -d 和 -o 参数也用这种方法获得。

最后，因为后续的挑战将会用到现在写的代码，请使用 下载代码 保存到本地或者提交到自己的 Github。

---------------------------------------------------------------------------------------------------------

挑战4

程序的执行过程如下，注意配置文件和输入的员工数据文件需要你自己创建并填入数据，可以参考上述的内容示例：

$ ./calculator.py -c test.cfg -d user.csv -o gongzi.csv

执行成功不需要输出信息到屏幕，执行失败或有异常出现则将错误信息输出到屏幕。

需要注意的是必须包含下列的处理方式：

    启动三个进程，使用进程1读取员工工资数据，使用进程2计算个税及社保，使用进程3将数据写入到输出的工资单数据文件中
    三个进程负责不同的工作，进程之间使用某种机制进行通信

目标

完成任务需要达成的目标：

    程序存放的位置 /home/shiyanlou/calculator.py
    程序必须采用多进程的方式处理员工工资数据，并保证进程间能够同步

提示语

下述实现方案仅供参考，会涉及到先前实验中学习到的知识点，如果自己对程序有足够的理解也可以不按照下述提示编写

    基于 multiprocessing 模块实现多进程
    基于 Queue 实现进程间通信
    实现完成后，可以考虑是否可以在计算环节的进程2实现为一个进程池？
    注意当使用 Queue 传递一个对象 a 的时候，如果对象中有列表属性，那么列表中的数据会丢失。例如 a.data 是 [2,3,4] 这样的列表，在 Queue 传递过去 get 得到的对象 a 中的 a.data 就变成了 []，这其实是 Python 中一个经常遇到的问题，深拷贝和浅拷贝的问题，对象在 Queue 这种应用场景下，其中的列表和字典不会被拷贝。感兴趣可以看下这个比赛中的第二道题目，就考察了深拷贝和浅拷贝的问题：https://www.shiyanlou.com/contests/lou3/challenges
    但是 queue put 和 get 是可以传递列表的。，比如列表data为 [2,3,4]，Queue 传递过去仍然能得到 [2,3,4]。
    实现方案可以考虑定义 queue1 和 queue2，实现三个进程如下：

    进程1：从用户文件中读取数据，然后得到一个列表 data，第一项是用户ID，第二项是税前工资，然后使用 queue1.put(data)
    进程2：queue1.get() 得到列表 data，第一项是用户ID，第二项是税前工资，然后计算后生成新的列表 newdata，包含社保，个税，税后工资等数据，然后使用 queue2.put(newdata)
    进程3：queue2.get() 得到列表 newdata，包含用户ID，税前工资，社保，个税，税后工资等数据，然后写入文件。

最后，因为后续的挑战将会用到现在写的代码，请使用 下载代码 保存到本地或者提交到自己的 Github。
知识点

    Python3 多进程
    进程间通信
    函数


